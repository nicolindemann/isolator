{"service_name":"travis-ci","service_job_id":"10389807","git":{"branch":"(detached from cc1693a)","head":{"id":"cc1693a6c864536466bb9a1e8d2f0a367ef42b9d","author_name":"James Harris","author_email":"james.harris@icecave.com.au","committer_name":"James Harris","committer_email":"james.harris@icecave.com.au","message":"Update README.md"},"remotes":[{"name":"origin","url":"git:\/\/github.com\/IcecaveStudios\/isolator.git"}]},"run_at":"2013-08-20 00:38:42 +0000","source_files":[{"name":"Icecave\/Isolator\/Generator.php","source":"<?php\nnamespace Icecave\\Isolator;\n\nuse ReflectionClass;\nuse ReflectionFunction;\n\n\/**\n * Generates an isolator that can accommodate calls to functions with reference parameters.\n *\/\nclass Generator\n{\n    public function __construct($ellipsisExpansion = 10, Isolator $isolator = null)\n    {\n        $this->ellipsisExpansion = $ellipsisExpansion;\n        $this->isolator = $isolator ?: new Isolator; \/\/ Note, Isolator::getIsolator is not used to avoid recursion.\n    }\n\n    public function generateClass(array $functionReflectors, $className = null, $baseClassName = 'Isolator')\n    {\n        if ($className === null) {\n            $className = 'Isolator' . self::$count++;\n        }\n\n        $code    = 'namespace ' . __NAMESPACE__ . ' {' . PHP_EOL;\n        $code .= 'class ' . $className . ' extends ' . $baseClassName . ' {' . PHP_EOL;\n        $code .= PHP_EOL;\n\n        foreach ($functionReflectors as $reflector) {\n            if ($this->requiresIsolatorProxy($reflector)) {\n                $code .= $this->generateProxyMethod($reflector);\n                $code .= PHP_EOL;\n            }\n        }\n\n        $code .= '} \/\/ End class.' . PHP_EOL;\n        $code .= '} \/\/ End namespace.' . PHP_EOL;\n\n        $this->isolator->eval($code);\n\n        return new ReflectionClass(__NAMESPACE__ . '\\\\' . $className);\n    }\n\n    public function requiresIsolatorProxy(ReflectionFunction $reflector)\n    {\n        if ($reflector->isDisabled()) {\n            return false;\n        } elseif ($reflector->returnsReference()) {\n            return true;\n        }\n\n        foreach ($reflector->getParameters() as $parameter) {\n            if ($parameter->isPassedByReference()) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    public function inspect(ReflectionFunction $reflector)\n    {\n        $minArity = 0;\n        $maxArity = 0;\n        $refIndices = array();\n\n        foreach ($reflector->getParameters() as $parameter) {\n            $refIndices[$maxArity++] = $parameter->isPassedByReference();\n\n            if (!$parameter->isOptional()) {\n                ++$minArity;\n            }\n\n            if ($parameter->getName() === '...') {\n                $ref = $parameter->isPassedByReference();\n                for ($count = 1; $count < $this->ellipsisExpansion; ++$count) {\n                    $refIndices[$maxArity++] = $ref;\n                }\n                break;\n            }\n        }\n\n        return array($minArity, $maxArity, $refIndices);\n    }\n\n    public function generateProxyMethod(ReflectionFunction $reflector)\n    {\n        list($minArity, $maxArity, $refIndices) = $this->inspect($reflector);\n        $name = $reflector->getName();\n        $code    = $this->generateSignature($name, $reflector->returnsReference(), $minArity, $maxArity, $refIndices) . ' {' . PHP_EOL;\n        $code .= $this->generateSwitch($name, $minArity, $maxArity);\n        $code .= $this->generateReturn($name, $maxArity);\n        $code .= '} \/\/ End function ' . $name . '.' . PHP_EOL;\n        $code .= PHP_EOL;\n\n        return $code;\n    }\n\n    protected function generateSignature($name, $returnsReference, $minArity, $maxArity, $refIndices)\n    {\n        $parameters = array();\n        for ($index = 0; $index < $maxArity; ++$index) {\n            $param = '';\n            if ($refIndices[$index]) {\n                $param .= '&';\n            }\n            $param .= '$_' . $index;\n            if ($index >= $minArity) {\n                $param .= ' = null';\n            }\n            $parameters[] = $param;\n        }\n\n        return sprintf(\n            'public function %s%s(%s)'\n            , $returnsReference ? '&' : ''\n            , str_replace('\\\\', '_', $name)\n            , implode(', ', $parameters)\n        );\n    }\n\n    protected function generateSwitch($name, $minArity, $maxArity)\n    {\n        if ($minArity === $maxArity) {\n            return '';\n        }\n\n        $code    = 'switch (func_num_args()) {' . PHP_EOL;\n\n        for ($arity = $minArity; $arity < $maxArity; ++$arity) {\n            $code .= sprintf(\n                'case %d: %s'\n                , $arity\n                , $this->generateReturn($name, $arity)\n            );\n        }\n\n        $code .= '} \/\/ End switch.' . PHP_EOL;\n\n        return $code;\n    }\n\n    protected function generateReturn($name, $arity)\n    {\n        $arguments = array();\n        for ($index = 0; $index < $arity; ++$index) {\n            $arguments[] = '$_' . $index;\n        }\n\n        return sprintf(\n            'return \\%s(%s);' . PHP_EOL\n            , $name\n            , implode(', ', $arguments)\n        );\n    }\n\n    private static $count = 0;\n    protected $ellipsisExpansionDepth;\n    protected $isolator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,10,10,10,null,null,null,2,1,1,null,2,2,2,null,2,2,2,2,2,2,null,2,2,null,2,null,2,null,null,null,null,5,1,4,1,null,null,3,3,2,null,3,null,2,null,null,null,null,5,5,5,null,5,5,null,5,5,5,null,5,4,4,4,4,4,null,5,null,5,null,null,null,null,1,1,1,1,1,1,1,null,1,null,null,null,null,1,1,1,1,1,1,1,1,1,1,1,1,null,1,null,1,1,1,1,null,null,null,null,1,1,null,null,1,null,1,1,null,1,1,1,1,null,1,null,1,null,null,null,null,1,1,1,1,null,1,null,1,1,1,null,null,null,null,null,null]},{"name":"Icecave\/Isolator\/Isolator.php","source":"<?php\nnamespace Icecave\\Isolator;\n\nuse ReflectionFunction;\n\n\/**\n * Isolate calls to global PHP functions.\n *\/\nclass Isolator\n{\n    \/**\n     * Forward a call onto global function.\n     *\n     * Support is also provided for the following function-esque language constructs:\n     *\n     *    - exit\n     *    - die\n     *    - echo\n     *    - include\n     *    - include_once\n     *    - require\n     *    - require_once\n     *\n     * @param string $name      The name of the global function to call.\n     * @param array  $arguments The arguments to the function.\n     *\n     * @return mixed The result of the function call.\n     *\/\n    public function __call($name, array $arguments)\n    {\n        switch ($name) {\n            case 'exit':\n            case 'die':\n                \/\/ @codeCoverageIgnoreStart\n                exit(current($arguments));\n                \/\/ @codeCoverageIgnoreEnd\n            case 'echo':\n                echo current($arguments);\n\n                return;\n            case 'eval':\n                return eval(current($arguments));\n            case 'include':\n                return include current($arguments);\n            case 'include_once':\n                return include_once current($arguments);\n            case 'require':\n                return require current($arguments);\n            case 'require_once':\n                return require_once current($arguments);\n            default:\n\n        }\n\n        return call_user_func_array($name, $arguments);\n    }\n\n    \/**\n     * Fetch an isolator instance.\n     *\n     * This convenience method returns the global isolator instance, or $instance if provided.\n     *\n     * @param Isolator|null $instance An existing isolator instance, if available.\n     *\n     * @return Isolator The global isolator instance, or $instance if provided.\n     *\/\n    public static function get(Isolator $instance = null)\n    {\n        if ($instance) {\n            return $instance;\n        }\n\n        return static::getIsolator();\n    }\n\n    \/**\n     * Fetch the isolator class name.\n     *\n     * @return string The concrete class name for the global isolator instance.\n     *\/\n    public static function className()\n    {\n        return get_class(static::get());\n    }\n\n    \/**\n     * Fetch the default isolator instance, constructing it if necessary.\n     *\n     * @param boolean        $handleReferences Indicates whether or not the isolator should account for functions with reference parameters and return types.\n     * @param Generator|null $generator        The Generator instance to use to construct the concreate isolator class, or null to use the default.\n     * @param Isolator|null  $isolator         The isolator used to access the global list of functions, or null to use the default.\n     *\/\n    public static function getIsolator($handleReferences = true, Generator $generator = null, Isolator $isolator = null)\n    {\n        \/\/ Global instance already initialized ...\n        if (self::$instance !== null) {\n            return self::$instance;\n        }\n\n        \/\/ No need to handle references, rely on default Isolator::__call() method ...\n        if (!$handleReferences) {\n            return self::$instance = new self;\n        }\n\n        \/\/ Construct an isolator generator to create the concreate isolator class ...\n        if ($generator === null) {\n            $generator = new Generator;\n        }\n\n        \/\/ Get a basic isolator to use for reflection ...\n        if ($isolator === null) {\n            $isolator = new self;\n        }\n\n        \/\/ Create reflectors for each of the globally defined functions ...\n        $functionReflectors = array();\n        foreach ($isolator->get_defined_functions() as $functions) {\n            foreach ($functions as $name) {\n                $functionReflectors[] = new ReflectionFunction($name);\n            }\n        }\n\n        \/\/ Generate the concrete isolator class and install it as the global instance ...\n        $classReflector = $generator->generateClass($functionReflectors);\n\n        return self::$instance = $classReflector->newInstance();\n    }\n\n    \/**\n     * Reset the default isolator instance.\n     *\/\n    public static function resetIsolator()\n    {\n        self::$instance = null;\n    }\n\n    private static $instance;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,10,10,null,null,null,10,1,null,1,9,4,8,1,7,1,6,1,5,1,4,null,4,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,2,1,null,null,2,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,6,4,null,null,null,6,2,null,null,null,4,3,3,null,null,4,3,3,null,null,4,4,4,4,4,4,null,null,4,null,4,null,null,null,null,null,null,null,13,13,null,null,null]},{"name":"Icecave\/Isolator\/IsolatorTrait.php","source":"<?php\nnamespace Icecave\\Isolator;\n\n\/**\n * Trait for convenient isolator usage.\n *\/\ntrait IsolatorTrait\n{\n    \/**\n     * Get the {@see Isolator} instance used by this object.\n     *\n     * @return Isolator The isolator set via {@see Isolator::setIsolator()}, or the default isolator if none has been set.\n     *\/\n    public function isolator()\n    {\n        return Isolator::get($this->isolator);\n    }\n\n    \/**\n     * Set the {@see Isolator} instance to be used by this object.\n     *\n     * @param Isolator|null $isolator The isolator instance to be used by this object, or null to use the global instance.\n     *\/\n    public function setIsolator(Isolator $isolator = null)\n    {\n        $this->isolator = $isolator;\n    }\n\n    private $isolator;\n}","coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,1,1,null,null,null]}]}